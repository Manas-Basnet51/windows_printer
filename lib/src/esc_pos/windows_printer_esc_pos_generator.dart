import 'dart:convert';
import 'dart:typed_data';
import '../windows_printer_enums.dart';
import '../windows_printer_models.dart';

/// Main ESC/POS command generator
///
/// ‚ö†Ô∏è IMPORTANT: Do not use emojis (üéâ, ‚ù§Ô∏è, etc.) in text content.
/// Thermal printers use ASCII/Extended ASCII character sets, not Unicode,
class WPESCPOSGenerator {
  static const List<int> _esc = [0x1B];
  static const List<int> _gs = [0x1D];
  static const List<int> _lf = [0x0A];
  static const List<int> _crlf = [0x0D, 0x0A];
  
  final WPPaperSize paperSize;
  final List<int> _buffer = [];
  
  WPESCPOSGenerator({this.paperSize = WPPaperSize.mm80}) {
    _buffer.addAll(_esc);
    _buffer.add(0x40);
  }
  
  /// Get the generated bytes
  List<int> getBytes() => List<int>.from(_buffer);
  
  /// Clear the buffer
  void clear() {
    _buffer.clear();
    _buffer.addAll(_esc);
    _buffer.add(0x40);
  }
  
  /// Add text with optional styling
  void text(String text, {WPTextStyle? style}) {
    style ??= const WPTextStyle();
    
    _setAlignment(style.align);
    _setTextFormatting(style);
    
    _buffer.addAll(utf8.encode(text));
    _buffer.addAll(_crlf);
    
    _resetFormatting();
  }
  
  /// Add a line break
  void feed([int lines = 1]) {
    for (int i = 0; i < lines; i++) {
      _buffer.addAll(_lf);
    }
  }
  
  /// Add a horizontal line
  void separator({String char = '-'}) {
    final lineWidth = paperSize.width ~/ 12;
    final line = char * lineWidth;
    text(line);
  }
  
  /// Cut the paper
  void cut({bool partial = true}) {
    _buffer.addAll(_gs);
    _buffer.add(0x56);
    _buffer.add(partial ? 0x01 : 0x00);
    
    _buffer.addAll(_gs);
    _buffer.add(0x56);
    _buffer.add(0x41);
    _buffer.add(partial ? 1 : 0);
  }
  
  /// Open cash drawer
  void openDrawer({int pin = 0, int onTime = 60, int offTime = 120}) {
    _buffer.addAll(_esc);
    _buffer.add(0x70);
    _buffer.add(pin);
    _buffer.add(onTime);
    _buffer.add(offTime);
  }
  
  /// Make beep sound
  void beep({int count = 1, int duration = 3}) {
    for (int i = 0; i < count; i++) {
      _buffer.addAll(_esc);
      _buffer.add(0x42);
      _buffer.add(duration.clamp(1, 9));
      
      _buffer.addAll([0x07]); // BEL character
      
      if (i < count - 1) {
        _buffer.addAll(_lf);
      }
    }
  }
  
  /// Add barcode
  void barcode(WPBarcodeType type, String data, {
    int height = 162,
    int width = 3,
    bool showText = true,
  }) {
    if (!_validateBarcodeData(type, data)) {
      return;
    }
    
    final List<int> barcodeData = utf8.encode(data);
    
    _setAlignment(WPTextAlign.center);
    
    _buffer.addAll(_gs);
    _buffer.add(0x48);
    _buffer.add(showText ? 0x02 : 0x00);
    
    _buffer.addAll(_gs);
    _buffer.add(0x66);
    _buffer.add(0x00);
    
    _buffer.addAll(_gs);
    _buffer.add(0x77);
    _buffer.add(width.clamp(2, 6));
    
    _buffer.addAll(_gs);
    _buffer.add(0x68);
    _buffer.add(height.clamp(1, 255));
    
    _buffer.addAll(_gs);
    _buffer.add(0x6B);
    _buffer.add(type.value);
    
    if (type.value <= 6) {
      _buffer.addAll(barcodeData);
      _buffer.add(0x00);
    } else {
      // Special handling for CODE128 - ensure length is correct
      if (type == WPBarcodeType.code128) {
        _buffer.add(barcodeData.length & 0xFF); // Ensure single byte length
      } else {
        _buffer.add(barcodeData.length);
      }
      _buffer.addAll(barcodeData);
    }
    
    _buffer.addAll(_crlf);
  }
  
  /// Add QR code
  void qrCode(String data, {int size = 6, int errorCorrection = 1}) {
    final dataBytes = utf8.encode(data);
    final length = dataBytes.length + 3;
    
    _buffer.addAll(_gs);
    _buffer.addAll([0x28, 0x6B]);
    _buffer.add(length & 0xFF);
    _buffer.add((length >> 8) & 0xFF);
    _buffer.addAll([0x31, 0x50, 0x30]);
    _buffer.addAll(dataBytes);
    
    _buffer.addAll(_gs);
    _buffer.addAll([0x28, 0x6B, 0x03, 0x00, 0x31, 0x43]);
    _buffer.add(size);
    
    _buffer.addAll(_gs);
    _buffer.addAll([0x28, 0x6B, 0x03, 0x00, 0x31, 0x45]);
    _buffer.add(errorCorrection);
    
    _buffer.addAll(_gs);
    _buffer.addAll([0x28, 0x6B, 0x03, 0x00, 0x31, 0x51, 0x30]);
  }
  
  /// Set text alignment
  void _setAlignment(WPTextAlign align) {
    _buffer.addAll(_esc);
    _buffer.add(0x61);
    _buffer.add(align.value);
  }
  
  /// Set text formatting
  void _setTextFormatting(WPTextStyle style) {
    _buffer.addAll(_esc);
    _buffer.add(0x45);
    _buffer.add(style.bold ? 1 : 0);
    
    _buffer.addAll(_esc);
    _buffer.add(0x2D);
    _buffer.add(style.underline ? 1 : 0);
    
    _buffer.addAll(_gs);
    _buffer.add(0x21);
    _buffer.add(style.size.value);
    
    _buffer.addAll(_gs);
    _buffer.add(0x42);
    _buffer.add(style.invert ? 1 : 0);
  }
  
  /// Reset formatting to defaults
  void _resetFormatting() {
    _buffer.addAll(_esc);
    _buffer.add(0x45);
    _buffer.add(0);
    
    _buffer.addAll(_esc);
    _buffer.add(0x2D);
    _buffer.add(0);
    
    _buffer.addAll(_gs);
    _buffer.add(0x21);
    _buffer.add(0);
    
    _buffer.addAll(_gs);
    _buffer.add(0x42);
    _buffer.add(0);
    
    _buffer.addAll(_esc);
    _buffer.add(0x61);
    _buffer.add(0);
  }
  
  /// Add raw bytes directly
  void raw(List<int> bytes) {
    _buffer.addAll(bytes);
  }
  
   /// Adds an image from pixel data
  void image(Uint8List imageData, int width, int height) {
    if (imageData.isEmpty || width <= 0 || height <= 0) return;
    
    _buffer.addAll(_esc);
    _buffer.add(0x33);
    _buffer.add(24);
    
    const int bandHeight = 24;
    
    for (int y = 0; y < height; y += bandHeight) {
      
      _buffer.addAll(_esc);
      _buffer.add(0x2A);
      _buffer.add(33);  
      _buffer.add(width & 0xFF); 
      _buffer.add((width >> 8) & 0xFF); 
      
      for (int x = 0; x < width; x++) {
        int byte1 = 0, byte2 = 0, byte3 = 0;
        
        for (int bit = 0; bit < 24; bit++) {
          final pixelY = y + bit;
          bool isBlack = false;
          
          if (pixelY < height) {
            final pixelIndex = (pixelY * width + x) * 4;
            if (pixelIndex + 3 < imageData.length) {
              final r = imageData[pixelIndex];
              final g = imageData[pixelIndex + 1];
              final b = imageData[pixelIndex + 2];
              final gray = (r * 0.299 + g * 0.587 + b * 0.114).round();
              isBlack = gray < 128;
            }
          }
          
          if (isBlack) {
            if (bit < 8) {
              byte1 |= (1 << bit);
            } else if (bit < 16) {
              byte2 |= (1 << (bit - 8));
            } else {
              byte3 |= (1 << (bit - 16));
            }
          }
        }
        
        _buffer.add(byte1);
        _buffer.add(byte2);
        _buffer.add(byte3);
      }
      
      _buffer.addAll(_lf);
    }
    
    _buffer.addAll(_esc);
    _buffer.add(0x32);
  }


  // Helper function: Validates barcode data based on the type.
  bool _validateBarcodeData(WPBarcodeType type, String data) {
    if (data.isEmpty) return false;
    
    switch (type) {
      case WPBarcodeType.upca:
        return RegExp(r'^\d{11,12}$').hasMatch(data);
      case WPBarcodeType.upce:
        return RegExp(r'^\d{6,8}$').hasMatch(data);
      case WPBarcodeType.ean13:
        return RegExp(r'^\d{12,13}$').hasMatch(data);
      case WPBarcodeType.ean8:
        return RegExp(r'^\d{7,8}$').hasMatch(data);
      case WPBarcodeType.code39:
        return RegExp(r'^[A-Z0-9 \-\.\$\/\+\%]*$').hasMatch(data) && data.length <= 255;
      case WPBarcodeType.code128:
        return data.length <= 255;
      case WPBarcodeType.codabar:
        return RegExp(r'^[0-9\-\.\$\/\+]*$').hasMatch(data) && data.length <= 255;
      case WPBarcodeType.code93:
        return data.length <= 255;
      case WPBarcodeType.itf:
        return RegExp(r'^\d+$').hasMatch(data) && data.length % 2 == 0 && data.length <= 255;
    }
  }
  
  /// Use this to test your printer
  void printTestPage() {
    text('=== ESC/POS TEST PAGE ===', style: const WPTextStyle(
      align: WPTextAlign.center,
      bold: true,
      size: WPTextSize.doubleHeightWidth
    ));
    
    feed(2);
    
    text('Text Formatting Test:', style: const WPTextStyle(bold: true));
    text('Normal text');
    text('Bold text', style: const WPTextStyle(bold: true));
    text('Underlined text', style: const WPTextStyle(underline: true));
    text('Large text', style: const WPTextStyle(size: WPTextSize.doubleHeight));
    text('Inverted text', style: const WPTextStyle(invert: true));
    
    feed();
    separator();
    feed();
    
    text('Barcode Test (FIXED):', style: const WPTextStyle(bold: true));
    barcode(WPBarcodeType.code128, 'HELLO123');
    
    feed();
    
    text('QR Code Test:', style: const WPTextStyle(bold: true));
    qrCode('https://example.com');
    
    feed(2);
    
    text('Hardware Test:', style: const WPTextStyle(bold: true));
    text('Beep test...');
    beep(count: 2);
    
    feed();
    text('Opening drawer...');
    openDrawer();
    
    feed(3);
    text('Test completed successfully!', style: const WPTextStyle(
      align: WPTextAlign.center,
      bold: true
    ));
    
    feed(3);
    cut();
  }
}